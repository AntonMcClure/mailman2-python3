#! @PYTHON@
#
# Copyright (C) 1998-2018 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
# USA.

"""Perform all necessary upgrades.

Usage: %(PROGRAM)s [options]

Options:
    -f/--force
        Force running the upgrade procedures.  Normally, if the version number
        of the installed Mailman matches the current version number (or a
        `downgrade' is detected), nothing will be done.

    -h/--help
        Print this text and exit.

    -l/--lowercase
        Convert all member email addresses to lowercase.

Use this script to help you update to the latest release of Mailman from
some previous version.  It knows about versions back to 1.0b4 (?).
"""

from __future__ import print_function, absolute_import, division, unicode_literals

import os
import sys
import time
import errno
import argparse
import shutil
import pickle
import marshal

import paths
import email.errors
from Mailman.Message import Message

sys.path.append("@VAR_PREFIX@/Mailman")
from Mailman import mm_cfg
from Mailman import Utils
from Mailman import MailList
from Mailman import Pending
from Mailman.LockFile import TimeOutError, AlreadyLockedError
from Mailman.i18n import C_
from Mailman.Queue.Switchboard import Switchboard
from Mailman.OldStyleMemberships import OldStyleMemberships
from Mailman.MemberAdaptor import BYBOUNCE, ENABLED
from Mailman.Bouncer import _BounceInfo
from Mailman.MemberAdaptor import UNKNOWN
from Mailman.Logging.Syslog import syslog

FRESH = 0
NOTFRESH = -1

LMVFILE = os.path.join(mm_cfg.DATA_DIR, 'last_mailman_version')
PROGRAM = sys.argv[0]


def parse_args():
    parser = argparse.ArgumentParser(description='Perform all necessary upgrades.')
    parser.add_argument('-f', '--force', action='store_true',
                       help='Force running the upgrade procedures')
    parser.add_argument('-l', '--lowercase', action='store_true',
                       help='Convert all member email addresses to lowercase')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Enable verbose output')
    return parser.parse_args()


def calcversions():
    # Returns a tuple of (lastversion, thisversion).  If the last version
    # could not be determined, lastversion will be FRESH or NOTFRESH,
    # depending on whether this installation appears to be fresh or not.  The
    # determining factor is whether there are files in the $var_prefix/logs
    # subdir or not.  The version numbers are HEX_VERSIONs.
    #
    # See if we stored the last updated version
    lastversion = None
    thisversion = mm_cfg.HEX_VERSION
    try:
        fp = open(LMVFILE, 'rb')
        data = fp.read()
        fp.close()
        # Ensure data is a string
        if isinstance(data, bytes):
            data = data.decode('utf-8', 'replace')
        lastversion = int(data, 16)
    except (IOError, ValueError):
        pass
    #
    # try to figure out if this is a fresh install
    if lastversion is None:
        lastversion = FRESH
        try:
            if os.listdir(mm_cfg.LOG_DIR):
                lastversion = NOTFRESH
        except OSError:
            pass
    return (lastversion, thisversion)


def makeabs(relpath):
    return os.path.join(mm_cfg.PREFIX, relpath)

def make_varabs(relpath):
    return os.path.join(mm_cfg.VAR_PREFIX, relpath)


def move_language_templates(mlist):
    listname = mlist.internal_name()
    # Ensure listname is a string
    if isinstance(listname, bytes):
        listname = listname.decode('utf-8', 'replace')
    print('Fixing language templates: %s' % listname)
    # Mailman 2.1 has a new cascading search for its templates, defined and
    # described in Utils.py:maketext().  Putting templates in the top level
    # templates/ subdir or the lists/<listname> subdir is deprecated and no
    # longer searched..
    #
    # What this means is that most templates can live in the global templates/
    # subdirectory, and only needs to be copied into the list-, vhost-, or
    # site-specific language directories when needed.
    #
    # Also, by default all standard (i.e. English) templates must now live in
    # the templates/en directory.  This update cleans up all the templates,
    # deleting more-specific duplicates (as calculated by md5 checksums) in
    # favor of more-global locations.
    #
    # First, get rid of any lists/<list> template or lists/<list>/en template
    # that is identical to the global templates/* default.
    for gtemplate in os.listdir(os.path.join(mm_cfg.TEMPLATE_DIR, 'en')):
        # BAW: get rid of old templates, e.g. admlogin.txt and
        # handle_opts.html
        try:
            fp = open(os.path.join(mm_cfg.TEMPLATE_DIR, gtemplate), 'rb')
        except IOError as e:
            if e.errno not in (errno.ENOENT, errno.EISDIR): raise
            # No global template or maybe a VCS directory
            continue

        gcksum = Utils.md5_new(fp.read()).digest()
        fp.close()
        # Match against the lists/<list>/* template
        try:
            fp = open(os.path.join(mlist.fullpath(), gtemplate), 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            tcksum = Utils.md5_new(fp.read()).digest()
            fp.close()
            if gcksum == tcksum:
                os.unlink(os.path.join(mlist.fullpath(), gtemplate))
        # Match against the lists/<list>/*.prev template
        try:
            fp = open(os.path.join(mlist.fullpath(), gtemplate + '.prev'), 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            tcksum = Utils.md5_new(fp.read()).digest()
            fp.close()
            if gcksum == tcksum:
                os.unlink(os.path.join(mlist.fullpath(), gtemplate + '.prev'))
        # Match against the lists/<list>/en/* templates
        try:
            fp = open(os.path.join(mlist.fullpath(), 'en', gtemplate), 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            tcksum = Utils.md5_new(fp.read()).digest()
            fp.close()
            if gcksum == tcksum:
                os.unlink(os.path.join(mlist.fullpath(), 'en', gtemplate))
        # Match against the templates/* template
        try:
            fp = open(os.path.join(mm_cfg.TEMPLATE_DIR, gtemplate), 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            tcksum = Utils.md5_new(fp.read()).digest()
            fp.close()
            if gcksum == tcksum:
                os.unlink(os.path.join(mm_cfg.TEMPLATE_DIR, gtemplate))
        # Match against the templates/*.prev template
        try:
            fp = open(os.path.join(mm_cfg.TEMPLATE_DIR, gtemplate + '.prev'), 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            tcksum = Utils.md5_new(fp.read()).digest()
            fp.close()
            if gcksum == tcksum:
                os.unlink(os.path.join(mm_cfg.TEMPLATE_DIR,
                                       gtemplate + '.prev'))


def dolist(listname):
    errors = 0
    # Ensure listname is a string and convert to lowercase
    if isinstance(listname, bytes):
        listname = listname.decode('utf-8', 'replace')
    listname = listname.lower()
    print('Updating mailing list: %s' % listname)
    mlist = MailList.MailList(listname, lock=0)
    try:
        mlist.Lock(0.5)
    except TimeOutError:
        print(C_('WARNING: could not acquire lock for list: '
                                '%(listname)s'), file=sys.stderr)
        return 1

    # Convert member addresses to lowercase if requested
    if args.lowercase:
        print('Converting member addresses to lowercase: %s' % listname)
        mlist.convert_member_addresses_to_lowercase()

    # Sanity check the invariant that every BYBOUNCE disabled member must have
    # bounce information.  Some earlier betas broke this.  BAW: we're
    # submerging below the MemberAdaptor interface, so skip this if we're not
    # using OldStyleMemberships.
    if isinstance(mlist._memberadaptor, OldStyleMemberships):
        noinfo = {}
        for addr, (reason, when) in mlist.delivery_status.items():
            if reason == BYBOUNCE and mlist.bounce_info.get(addr, None) is None:
                noinfo[addr] = reason, when
        # What to do about these folks with a BYBOUNCE delivery status and no
        # bounce info?  This number should be very small, and I think it's
        # fine to simple re-enable them and let the bounce machinery
        # re-disable them if necessary.
        n = len(noinfo)
        if n > 0:
            print(C_(
                'Resetting %(n)s BYBOUNCEs disabled addrs with no bounce info'))
            for addr in noinfo.keys():
                mlist.setDeliveryStatus(addr, ENABLED)

    # Update the held requests database
    print(C_("""Updating the held requests database."""))
    mlist._UpdateRecords()

    mbox_dir = make_varabs('archives/private/%s.mbox' % (listname))
    mbox_file = make_varabs('archives/private/%s.mbox/%s' % (listname,
                                                             listname))

    o_pub_mbox_file = make_varabs('archives/public/%s' % (listname))
    o_pri_mbox_file = make_varabs('archives/private/%s' % (listname))

    html_dir = o_pri_mbox_file
    o_html_dir = makeabs('public_html/archives/%s' % (listname))
    #
    # make the mbox directory if it's not there.
    #
    if not os.path.exists(mbox_dir):
        ou = os.umask(0)
        os.mkdir(mbox_dir, 0o02775)
        os.umask(ou)
    else:
        # this shouldn't happen, but hey, just in case
        if not os.path.isdir(mbox_dir):
            print(C_("""\
For some reason, %(mbox_dir)s exists as a file.  This won't work with
b6, so I'm renaming it to %(mbox_dir)s.tmp and proceeding."""))
            os.rename(mbox_dir, "%s.tmp" % (mbox_dir))
            ou = os.umask(0)
            os.mkdir(mbox_dir, 0o2775)
            os.umask(ou)

    # Move any existing mboxes around, but watch out for both a public and a
    # private one existing
    if os.path.isfile(o_pri_mbox_file) and os.path.isfile(o_pub_mbox_file):
        if mlist.archive_private:
            print(C_("""\

%(listname)s has both public and private mbox archives.  Since this list
currently uses private archiving, I'm installing the private mbox archive
-- %(o_pri_mbox_file)s -- as the active archive, and renaming
        %(o_pub_mbox_file)s
to
        %(o_pub_mbox_file)s.preb6

You can integrate that into the archives if you want by using the 'arch'
script.
""") % (listname, o_pri_mbox_file, o_pub_mbox_file,
        o_pub_mbox_file))
            os.rename(o_pub_mbox_file, "%s.preb6" % (o_pub_mbox_file))
        else:
            print(C_("""\
%s has both public and private mbox archives.  Since this list
currently uses public archiving, I'm installing the public mbox file
archive file (%s) as the active one, and renaming
        %s
    to
        %s.preb6

You can integrate that into the archives if you want by using the 'arch'
script.
""") % (listname, o_pub_mbox_file, o_pri_mbox_file,
        o_pri_mbox_file))
            os.rename(o_pri_mbox_file, "%s.preb6" % (o_pri_mbox_file))
    #
    # move private archive mbox there if it's around
    # and take into account all sorts of absurdities
    #
    print('- updating old private mbox file')
    if os.path.exists(o_pri_mbox_file):
        if os.path.isfile(o_pri_mbox_file):
            os.rename(o_pri_mbox_file, mbox_file)
        elif not os.path.isdir(o_pri_mbox_file):
            newname = "%s.mm_install-dunno_what_this_was_but_its_in_the_way" \
                      % o_pri_mbox_file
            os.rename(o_pri_mbox_file, newname)
            print(C_("""\
    unknown file in the way, moving
        %(o_pri_mbox_file)s
    to
        %(newname)s"""))
        else:
            # directory
            print('Nothing to do.')


    #
    # move public archive mbox there if it's around
    # and take into account all sorts of absurdities.
    #
    print('- updating old public mbox file')
    if os.path.exists(o_pub_mbox_file):
        if os.path.isfile(o_pub_mbox_file):
            os.rename(o_pub_mbox_file, mbox_file)
        elif not os.path.isdir(o_pub_mbox_file):
            newname = "%s.mm_install-dunno_what_this_was_but_its_in_the_way" \
                      % o_pub_mbox_file
            os.rename(o_pub_mbox_file, newname)
            print(C_("""\
    unknown file in the way, moving
        %(o_pub_mbox_file)s
    to
        %(newname)s"""))
        else: # directory
            print('Nothing to do.')

    #
    # move the html archives there
    #
    if os.path.isdir(o_html_dir):
        os.rename(o_html_dir, html_dir)
        #
        # chmod the html archives
        #
        os.chmod(html_dir, 0o02775)
    # BAW: Is this still necessary?!
    mlist.Save()
    #
    # check to see if pre-b4 list-specific templates are around
    # and move them to the new place if there's not already
    # a new one there
    #
    # There is a problem with the following if the list name is equal
    # to a language code. All the templates get moved from templates/xx
    # to lists/xx. To avoid this, test the list name, and if it is 'en'
    # or matches a name in the messages directory, just skip this step.
    if (mlist._internal_name != 'en' and
        mlist._internal_name not in os.listdir(mm_cfg.MESSAGES_DIR)):
        # It's okay to move the templates.
        tmpl_dir = os.path.join(mm_cfg.PREFIX, "templates")
        list_dir = mm_cfg.LIST_DATA_DIR
        b4_tmpl_dir = os.path.join(tmpl_dir, mlist._internal_name)
        new_tmpl_dir = os.path.join(list_dir, mlist._internal_name)
        if os.path.exists(b4_tmpl_dir):
            print( C_("""\
- This list looks like it might have <= b4 list templates around"""))
            for f in os.listdir(b4_tmpl_dir):
                o_tmpl = os.path.join(b4_tmpl_dir, f)
                n_tmpl = os.path.join(new_tmpl_dir, f)
                if os.path.exists(o_tmpl):
                    if not os.path.exists(n_tmpl):
                        os.rename(o_tmpl, n_tmpl)
                        print(C_('- moved %(o_tmpl)s to %(n_tmpl)s'))
                    else:
                        print(C_("""\
- both %(o_tmpl)s and %(n_tmpl)s exist, leaving untouched"""))
                else:
                    print(C_("""\
- %(o_tmpl)s doesn't exist, leaving untouched"""))
    #
    # Move all the templates to the en language subdirectory as required for
    # Mailman 2.1
    #
    move_language_templates(mlist)
    # Avoid eating filehandles with the list lockfiles
    mlist.Unlock()
    return 0


def archive_path_fixer(unused_arg, dir, files):
    # Passed to os.path.walk to fix the perms on old html archives.
    for f in files:
        abs = os.path.join(dir, f)
        if os.path.isdir(abs):
            if f == "database":
                os.chmod(abs, 0o02770)
            else:
                os.chmod(abs, 0o02775)
        elif os.path.isfile(abs):
            os.chmod(abs, 0o0664)

def remove_old_sources(module):
    # Also removes old directories.
    src = '%s/%s' % (mm_cfg.PREFIX, module)
    pyc = src + "c"
    if os.path.isdir(src):
        print(C_('removing directory %(src)s and everything underneath'))
        shutil.rmtree(src)
    elif os.path.exists(src):
        print(C_('removing %(src)s'))
        try:
            os.unlink(src)
        except os.error as rest:
            print(C_("Warning: couldn't remove %(src)s -- %(rest)s"))
    if module.endswith('.py') and os.path.exists(pyc):
        try:
            os.unlink(pyc)
        except os.error as rest:
            print(C_("couldn't remove old file %(pyc)s -- %(rest)s"))


def update_qfiles():
    print('updating old qfiles')
    prefix = str(time.time()) + '+'
    # Be sure the qfiles/in directory exists (we don't really need the
    # switchboard object, but it's convenient for creating the directory).
    sb = Switchboard(mm_cfg.INQUEUE_DIR)
    for filename in os.listdir(mm_cfg.QUEUE_DIR):
        # Updating means just moving the .db and .msg files to qfiles/in where
        # it should be dequeued, converted, and processed normally.
        if filename.endswith('.msg'):
            oldmsgfile = os.path.join(mm_cfg.QUEUE_DIR, filename)
            newmsgfile = os.path.join(mm_cfg.INQUEUE_DIR, prefix + filename)
            os.rename(oldmsgfile, newmsgfile)
        elif filename.endswith('.db'):
            olddbfile = os.path.join(mm_cfg.QUEUE_DIR, filename)
            newdbfile = os.path.join(mm_cfg.INQUEUE_DIR, prefix + filename)
            os.rename(olddbfile, newdbfile)
    # Now update for the Mailman 2.1.5 qfile format.  For every filebase in
    # the qfiles/* directories that has both a .pck and a .db file, pull the
    # data out and re-queue them.
    for dirname in os.listdir(mm_cfg.QUEUE_DIR):
        dirpath = os.path.join(mm_cfg.QUEUE_DIR, dirname)
        if dirpath == mm_cfg.BADQUEUE_DIR:
            # The files in qfiles/bad can't possibly be pickles
            continue
        sb = Switchboard(dirpath)
        try:
            for filename in os.listdir(dirpath):
                filepath = os.path.join(dirpath, filename)
                filebase, ext = os.path.splitext(filepath)
                # A bug in Mailman 2.1.9 left .bak files behind in some
                # circumstances. It should be safe to remove them.
                if ext == '.bak':
                    os.remove(filepath)
                # Handle the .db metadata files as part of the handling of the
                # .pck or .msg message files.
                if ext not in ('.pck', '.msg'):
                    continue
                msg, data = dequeue(filebase)
                if msg is not None and data is not None:
                    sb.enqueue(msg, data)
        except EnvironmentError as e:
            if e.errno != errno.ENOTDIR:
                raise
            print(C_('Warning!  Not a directory: %(dirpath)s'))


# Implementations taken from the pre-2.1.5 Switchboard
def ext_read(filename):
    fp = open(filename, 'rb')
    d = marshal.load(fp)
    # Update from version 2 files
    if d.get('version', 0) == 2:
        del d['filebase']
    
    # Convert any bytes in the loaded data to strings
    for key, value in list(d.items()):
        if isinstance(key, bytes):
            del d[key]
            key = key.decode('utf-8', 'replace')
        if isinstance(value, bytes):
            value = value.decode('utf-8', 'replace')
        elif isinstance(value, list):
            value = [v.decode('utf-8', 'replace') if isinstance(v, bytes) else v for v in value]
        elif isinstance(value, dict):
            new_dict = {}
            for k, v in value.items():
                if isinstance(k, bytes):
                    k = k.decode('utf-8', 'replace')
                if isinstance(v, bytes):
                    v = v.decode('utf-8', 'replace')
                new_dict[k] = v
            value = new_dict
        d[key] = value
    
    # Do the reverse conversion (repr -> float)
    for attr in ['received_time']:
        try:
            sval = d[attr]
        except KeyError:
            pass
        else:
            # Do a safe eval by setting up a restricted execution
            # environment.  This may not be strictly necessary since we
            # know they are floats, but it can't hurt.
            d[attr] = eval(sval, {'__builtins__': {}})
    fp.close()
    return d


def dequeue(filebase):
    # Calculate the .db and .msg filenames from the given filebase.
    msgfile = os.path.join(filebase + '.msg')
    pckfile = os.path.join(filebase + '.pck')
    dbfile = os.path.join(filebase + '.db')
    msg = None
    try:
        data = ext_read(dbfile)
        os.unlink(dbfile)
    except EnvironmentError as e:
        if e.errno != errno.ENOENT: raise
        data = {}
    
    # Convert any bytes in the data dict to strings
    for key, value in list(data.items()):
        if isinstance(key, bytes):
            del data[key]
            key = key.decode('utf-8', 'replace')
        if isinstance(value, bytes):
            value = value.decode('utf-8', 'replace')
        data[key] = value
    
    # Between 2.1b4 and 2.1b5, the `rejection-notice` key in the metadata
    # was renamed to `rejection_notice`
    if data.get('rejection-notice', None) is not None:
        data['rejection_notice'] = data['rejection-notice']
        del data['rejection-notice']
    
    msgfp = None
    try:
        try:
            msgfp = open(pckfile, 'rb')
            msg = pickle.load(msgfp, fix_imports=True, encoding='latin1')
            if not data:
                # There was no .db file. Is this a post 2.1.5 .pck?
                try:
                    data = pickle.load(msgfp, fix_imports=True, encoding='latin1')
                    # Convert any bytes in the loaded data to strings
                    if isinstance(data, dict):
                        for key, value in list(data.items()):
                            if isinstance(key, bytes):
                                del data[key]
                                key = key.decode('utf-8', 'replace')
                            if isinstance(value, bytes):
                                value = value.decode('utf-8', 'replace')
                            data[key] = value
                except EOFError:
                    pass
            os.unlink(pckfile)
        except EnvironmentError as e:
            if e.errno != errno.ENOENT: raise
            msgfp = None
            try:
                msgfp = open(msgfile, 'rb')
                msg = Message_from_file(msgfp)
                os.unlink(msgfile)
            except EnvironmentError as e:
                if e.errno != errno.ENOENT: raise
            except (email.errors.MessageParseError, ValueError) as e:
                print(C_('message is unparsable: %(filebase)s'))
                msgfp.close()
                msgfp = None
                if mm_cfg.QRUNNER_SAVE_BAD_MESSAGES:
                    sb = Switchboard(mm_cfg.BADQUEUE_DIR)
                    os.rename(msgfile, os.path.join(
                        mm_cfg.BADQUEUE_DIR, filebase + '.txt'))
                else:
                    os.unlink(msgfile)
                msg = data = None
        except EOFError:
            print(C_('Warning!  Deleting empty .pck file: %(pckfile)s'))
            os.unlink(pckfile)
    finally:
        if msgfp:
            msgfp.close()
    return msg, data


def update_pending():
    file20 = os.path.join(mm_cfg.DATA_DIR, 'pending_subscriptions.db')
    file214 = os.path.join(mm_cfg.DATA_DIR, 'pending.pck')
    db = None
    # Try to load the Mailman 2.0 file
    try:
        fp = open(file20, 'rb')
    except IOError as e:
        if e.errno != errno.ENOENT: raise
    else:
        print('Updating Mailman 2.0 pending_subscriptions.db database')
        db = marshal.load(fp)
        # Convert to the pre-Mailman 2.1.5 format
        db = Pending._update(db)
        # Convert any bytes to strings
        if isinstance(db, dict):
            new_db = {}
            for key, value in db.items():
                if isinstance(key, bytes):
                    key = key.decode('utf-8', 'replace')
                if isinstance(value, bytes):
                    value = value.decode('utf-8', 'replace')
                elif isinstance(value, (list, tuple)):
                    value = list(value)  # Convert tuple to list for modification
                    for i, v in enumerate(value):
                        if isinstance(v, bytes):
                            value[i] = v.decode('utf-8', 'replace')
                new_db[key] = value
            db = new_db
    if db is None:
        # Try to load the Mailman 2.1.x where x < 5, file
        try:
            fp = open(file214, 'rb')
        except IOError as e:
            if e.errno != errno.ENOENT: raise
        else:
            print('Updating Mailman 2.1.4 pending.pck database')
            db = pickle.load(fp, fix_imports=True, encoding='latin1')
            # Convert any bytes to strings
            if isinstance(db, dict):
                new_db = {}
                for key, value in db.items():
                    if isinstance(key, bytes):
                        key = key.decode('utf-8', 'replace')
                    if isinstance(value, bytes):
                        value = value.decode('utf-8', 'replace')
                    elif isinstance(value, (list, tuple)):
                        value = list(value)  # Convert tuple to list for modification
                        for i, v in enumerate(value):
                            if isinstance(v, bytes):
                                value[i] = v.decode('utf-8', 'replace')
                    new_db[key] = value
                db = new_db
    if db is None:
        print('Nothing to do.')
        return
    # Now upgrade the database to the 2.1.5 format.  Each list now has its own
    # pending.pck file, but only the RE_ENABLE operation actually recorded the
    # listname in the request.  For the SUBSCRIPTION, UNSUBSCRIPTION, and
    # CHANGE_OF_ADDRESS operations, we know the address of the person making
    # the request so we can repend this request just for the lists the person
    # is a member of.  For the HELD_MESSAGE operation, we can check the list's
    # requests.pck file for correlation.  Evictions will take care of any
    # misdirected pendings.
    reenables_by_list = {}
    addrops_by_address = {}
    holds_by_id = {}
    subs_by_address = {}
    for key, val in db.items():
        if key in ('evictions', 'version'):
            continue
        try:
            op = val[0]
            data = val[1:]
        except (IndexError, ValueError):
            print(C_('Ignoring bad pended data: %(key)s: %(val)s'))
            continue
        if op in (Pending.UNSUBSCRIPTION, Pending.CHANGE_OF_ADDRESS):
            # data[0] is the address being unsubscribed
            addrops_by_address.setdefault(data[0], []).append((key, val))
        elif op == Pending.SUBSCRIPTION:
            # data[0] is a UserDesc object
            addr = data[0].address
            subs_by_address.setdefault(addr, []).append((key, val))
        elif op == Pending.RE_ENABLE:
            # data[0] is the mailing list's internal name
            reenables_by_list.setdefault(data[0], []).append((key, val))
        elif op == Pending.HELD_MESSAGE:
            # data[0] is the hold id.  There better only be one entry per id
            id = data[0]
            if holds_by_id.get(id, None) is not None:
                print(C_('WARNING: Ignoring duplicate pending ID: %(id)s.'))
            else:
                holds_by_id[id] = (key, val)
    # Now we have to lock every list and re-pend all the appropriate
    # requests.  Note that this will reset all the expiration dates, but that
    # should be fine.
    for listname in Utils.list_names():
        mlist = MailList.MailList(listname)
        # This is not the most efficient way to do this because it loads and
        # saves the pending.pck file each time. :(
        try:
            for cookie, data in reenables_by_list.get(listname, []):
                mlist.pend_repend(cookie, data)
            for id, (cookie, data) in holds_by_id.items():
                try:
                    rec = mlist.GetRecord(id)
                except KeyError:
                    # Not for this list
                    pass
                else:
                    mlist.pend_repend(cookie, data)
                    del holds_by_id[id]
            for addr, recs in subs_by_address.items():
                # We shouldn't have a subscription confirmation if the address
                # is already a member of the mailing list.
                if mlist.isMember(addr):
                    continue
                for cookie, data in recs:
                    mlist.pend_repend(cookie, data)
            for addr, recs in addrops_by_address.items():
                # We shouldn't have unsubscriptions or change of address
                # requests for addresses which aren't members of the list.
                if not mlist.isMember(addr):
                    continue
                for cookie, data in recs:
                    mlist.pend_repend(cookie, data)
            mlist.Save()
        finally:
            mlist.Unlock()
    try:
        os.unlink(file20)
    except OSError as e:
        if e.errno != errno.ENOENT: raise
    try:
        os.unlink(file214)
    except OSError as e:
        if e.errno != errno.ENOENT: raise


def domsort(addr):
    # Sort email addresses by domain name
    return addr.split('@')[-1]


def init_digest_vars(mlist):
    """Initialize missing digest-related variables with default values."""
    # List of digest variables and their default values
    digest_vars = {
        'digestable': True,
        'nondigestable': mm_cfg.DEFAULT_NONDIGESTABLE,
        'digest_volume': 1,
        'digest_issue': 1,
        'digest_last_sent_at': 0,
        'digest_next_due_at': 0,
        'digest_volume_frequency': mm_cfg.DEFAULT_DIGEST_VOLUME_FREQUENCY,
        'digest_members': {},
        'members': {},  # Regular members dictionary
        'user_options': {},  # User preferences
        'language': {},  # User language preferences
        'usernames': {},  # Username mappings
        'passwords': {},  # Password storage
        'bounce_info': {},  # Bounce information
        'delivery_status': {},  # Delivery status information
        'new_member_options': mm_cfg.DEFAULT_NEW_MEMBER_OPTIONS,
        'respond_to_post_requests': mm_cfg.DEFAULT_RESPOND_TO_POST_REQUESTS,
        'advertised': mm_cfg.DEFAULT_LIST_ADVERTISED,
        'max_num_recipients': mm_cfg.DEFAULT_MAX_NUM_RECIPIENTS,
        'max_message_size': mm_cfg.DEFAULT_MAX_MESSAGE_SIZE,
        'host_name': mm_cfg.DEFAULT_HOST_NAME or mm_cfg.DEFAULT_EMAIL_HOST,
        'web_page_url': mm_cfg.DEFAULT_URL_PATTERN % mm_cfg.DEFAULT_URL_HOST,
        'owner': [],  # List owners
        'moderator': [],  # List moderators
        'reply_goes_to_list': mm_cfg.DEFAULT_REPLY_GOES_TO_LIST,
        'reply_to_address': '',
        'first_strip_reply_to': mm_cfg.DEFAULT_FIRST_STRIP_REPLY_TO,
        'admin_immed_notify': mm_cfg.DEFAULT_ADMIN_IMMED_NOTIFY,
        'admin_notify_mchanges': mm_cfg.DEFAULT_ADMIN_NOTIFY_MCHANGES,
        'require_explicit_destination': mm_cfg.DEFAULT_REQUIRE_EXPLICIT_DESTINATION,
        'acceptable_aliases': mm_cfg.DEFAULT_ACCEPTABLE_ALIASES,
        'umbrella_list': mm_cfg.DEFAULT_UMBRELLA_LIST,
        'umbrella_member_suffix': mm_cfg.DEFAULT_UMBRELLA_MEMBER_ADMIN_SUFFIX,
        'regular_exclude_lists': mm_cfg.DEFAULT_REGULAR_EXCLUDE_LISTS,
        'regular_exclude_ignore': mm_cfg.DEFAULT_REGULAR_EXCLUDE_IGNORE,
        'regular_include_lists': mm_cfg.DEFAULT_REGULAR_INCLUDE_LISTS,
        'send_reminders': mm_cfg.DEFAULT_SEND_REMINDERS,
        'send_welcome_msg': mm_cfg.DEFAULT_SEND_WELCOME_MSG,
        'send_goodbye_msg': mm_cfg.DEFAULT_SEND_GOODBYE_MSG,
        'bounce_matching_headers': mm_cfg.DEFAULT_BOUNCE_MATCHING_HEADERS,
        'header_filter_rules': [],
        'from_is_list': mm_cfg.DEFAULT_FROM_IS_LIST,
        'anonymous_list': mm_cfg.DEFAULT_ANONYMOUS_LIST,
        'real_name': mlist.internal_name()[0].upper() + mlist.internal_name()[1:],
        'description': '',
        'info': '',
        'welcome_msg': '',
        'goodbye_msg': '',
        'subscribe_policy': mm_cfg.DEFAULT_SUBSCRIBE_POLICY,
        'subscribe_auto_approval': mm_cfg.DEFAULT_SUBSCRIBE_AUTO_APPROVAL,
        'unsubscribe_policy': mm_cfg.DEFAULT_UNSUBSCRIBE_POLICY,
        'private_roster': mm_cfg.DEFAULT_PRIVATE_ROSTER,
        'obscure_addresses': mm_cfg.DEFAULT_OBSCURE_ADDRESSES,
        'admin_member_chunksize': mm_cfg.DEFAULT_ADMIN_MEMBER_CHUNKSIZE,
        'administrivia': mm_cfg.DEFAULT_ADMINISTRIVIA,
        'drop_cc': mm_cfg.DEFAULT_DROP_CC,
        'preferred_language': mm_cfg.DEFAULT_SERVER_LANGUAGE,
        'available_languages': [],
        'include_rfc2369_headers': 1,
        'include_list_post_header': 1,
        'include_sender_header': 1,
        'filter_mime_types': mm_cfg.DEFAULT_FILTER_MIME_TYPES,
        'pass_mime_types': mm_cfg.DEFAULT_PASS_MIME_TYPES,
        'filter_filename_extensions': mm_cfg.DEFAULT_FILTER_FILENAME_EXTENSIONS,
        'pass_filename_extensions': mm_cfg.DEFAULT_PASS_FILENAME_EXTENSIONS,
        'filter_content': mm_cfg.DEFAULT_FILTER_CONTENT,
        'collapse_alternatives': mm_cfg.DEFAULT_COLLAPSE_ALTERNATIVES,
        'convert_html_to_plaintext': mm_cfg.DEFAULT_CONVERT_HTML_TO_PLAINTEXT,
        'filter_action': mm_cfg.DEFAULT_FILTER_ACTION,
        'personalize': 0,
        'default_member_moderation': mm_cfg.DEFAULT_DEFAULT_MEMBER_MODERATION,
        'emergency': 0,
        'member_verbosity_threshold': mm_cfg.DEFAULT_MEMBER_VERBOSITY_THRESHOLD,
        'member_verbosity_interval': mm_cfg.DEFAULT_MEMBER_VERBOSITY_INTERVAL,
        'member_moderation_action': 0,
        'member_moderation_notice': '',
        'dmarc_moderation_action': mm_cfg.DEFAULT_DMARC_MODERATION_ACTION,
        'dmarc_quarantine_moderation_action': mm_cfg.DEFAULT_DMARC_QUARANTINE_MODERATION_ACTION,
        'dmarc_none_moderation_action': mm_cfg.DEFAULT_DMARC_NONE_MODERATION_ACTION,
        'dmarc_moderation_notice': '',
        'dmarc_moderation_addresses': [],
        'dmarc_wrapped_message_text': mm_cfg.DEFAULT_DMARC_WRAPPED_MESSAGE_TEXT,
        'equivalent_domains': mm_cfg.DEFAULT_EQUIVALENT_DOMAINS,
        'accept_these_nonmembers': [],
        'hold_these_nonmembers': [],
        'reject_these_nonmembers': [],
        'discard_these_nonmembers': [],
        'forward_auto_discards': mm_cfg.DEFAULT_FORWARD_AUTO_DISCARDS
    }
    
    # Initialize any missing variables
    for var, default in digest_vars.items():
        if not hasattr(mlist, var):
            try:
                # If default is a call to mm_cfg, try to get the attribute
                if isinstance(default, str) and 'mm_cfg.' in default:
                    try:
                        default = eval(default)
                    except AttributeError:
                        print(C_('Warning: mm_cfg attribute %(attr)s not found, using empty value') % {
                            'attr': default.split('mm_cfg.')[1]
                        })
                        default = None
                
                print(C_('Initializing missing variable %(var)s for list %(listname)s') % {
                    'var': var,
                    'listname': mlist.internal_name()
                })
                setattr(mlist, var, default)
            except Exception as e:
                print(C_('Warning: Could not initialize %(var)s: %(error)s') % {
                    'var': var,
                    'error': str(e)
                })

def upgrade(mlist):
    """Upgrade the list to the current version."""
    try:
        # Initialize any missing digest variables
        init_digest_vars(mlist)
        
        # Convert all email addresses to lowercase
        for addr in list(mlist.members):
            if addr != addr.lower():
                mlist.members[addr.lower()] = mlist.members[addr]
                del mlist.members[addr]
                
        for addr in list(mlist.digest_members):
            if addr != addr.lower():
                mlist.digest_members[addr.lower()] = mlist.digest_members[addr]
                del mlist.digest_members[addr]
                
        # Handle owner list differently since it's a list, not a dict
        if hasattr(mlist, 'owner') and isinstance(mlist.owner, list):
            new_owners = []
            for addr in mlist.owner:
                if isinstance(addr, str) and addr != addr.lower():
                    new_owners.append(addr.lower())
                else:
                    new_owners.append(addr)
            mlist.owner = new_owners
        else:
            for addr in list(mlist.owner):
                if addr != addr.lower():
                    mlist.owner[addr.lower()] = mlist.owner[addr]
                    del mlist.owner[addr]
                
        # Handle moderator list differently since it's a list, not a dict
        if hasattr(mlist, 'moderator') and isinstance(mlist.moderator, list):
            new_moderators = []
            for addr in mlist.moderator:
                if isinstance(addr, str) and addr != addr.lower():
                    new_moderators.append(addr.lower())
                else:
                    new_moderators.append(addr)
            mlist.moderator = new_moderators
        else:
            for addr in list(mlist.moderator):
                if addr != addr.lower():
                    mlist.moderator[addr.lower()] = mlist.moderator[addr]
                    del mlist.moderator[addr]
                
        for addr in list(mlist.bounce_info):
            if addr != addr.lower():
                mlist.bounce_info[addr.lower()] = mlist.bounce_info[addr]
                del mlist.bounce_info[addr]
                
        for addr in list(mlist.delivery_status):
            if addr != addr.lower():
                mlist.delivery_status[addr.lower()] = mlist.delivery_status[addr]
                del mlist.delivery_status[addr]
                
        for addr in list(mlist.user_options):
            if addr != addr.lower():
                mlist.user_options[addr.lower()] = mlist.user_options[addr]
                del mlist.user_options[addr]
                
        # Don't convert passwords to lowercase
        # for addr in list(mlist.passwords):
        #     if addr != addr.lower():
        #         mlist.passwords[addr.lower()] = mlist.passwords[addr]
        #         del mlist.passwords[addr]
                
        for addr in list(mlist.language):
            if addr != addr.lower():
                mlist.language[addr.lower()] = mlist.language[addr]
                del mlist.language[addr]
                
        for addr in list(mlist.usernames):
            if addr != addr.lower():
                mlist.usernames[addr.lower()] = mlist.usernames[addr]
                del mlist.usernames[addr]

        # Ensure the list directory exists
        list_dir = os.path.dirname(mlist._full_path)
        if not os.path.exists(list_dir):
            print(C_('Creating list directory: %(dir)s') % {'dir': list_dir})
            os.makedirs(list_dir, mode=0o2775)
            # Set group ownership if possible
            try:
                import grp
                mailman_gid = grp.getgrnam('mailman').gr_gid
                os.chown(list_dir, -1, mailman_gid)
            except (ImportError, KeyError):
                pass

        # Save the list configuration
        try:
            mlist.Save()
        except (IOError, OSError) as e:
            print(C_('Error saving list configuration: %(error)s') % {'error': str(e)})
            # Try to save to a backup location
            backup_path = os.path.join(list_dir, 'config.pck.bak')
            try:
                with open(backup_path, 'wb') as fp:
                    pickle.dump(mlist.__dict__, fp, protocol=4, fix_imports=True)
                print(C_('Saved backup configuration to %(path)s') % {'path': backup_path})
            except Exception as e:
                print(C_('Failed to save backup configuration: %(error)s') % {'error': str(e)})
            raise
    except Exception as e:
        print(C_('Error during upgrade: %(error)s') % {'error': str(e)})
        raise


def main():
    try:
        args = parse_args()
    except SystemExit as e:
        if e.code == 2:  # Invalid arguments
            usage(1)
        raise

    # Calculate the versions
    lastversion, thisversion = calcversions()

    # If this is a fresh install, we don't need to do anything
    if lastversion == FRESH:
        print(C_('This appears to be a fresh installation.'))
        print(C_('No upgrade is necessary.'))
        # Early check: try to load all lists and print a summary
        list_names = Utils.list_names()
        ok = 0
        fail = 0
        for listname in list_names:
            try:
                if isinstance(listname, bytes):
                    listname = listname.decode('utf-8', 'replace')
                listname = listname.lower()
                mlist = MailList.MailList(listname, lock=0)
                ok += 1
            except Exception as e:
                fail += 1
                print('  [WARN] Could not load list "%s": %s' % (listname, str(e)))
        if fail == 0:
            print('All %d lists loaded successfully, no upgrade necessary.' % ok)
        else:
            print('%d lists loaded successfully, %d lists had errors. No upgrade necessary.' % (ok, fail))
        sys.exit(0)

    # If this is not a fresh install, but we can't determine the last version,
    # we need to force the upgrade
    if lastversion == NOTFRESH:
        if not args.force:
            print(C_("""\
This appears to be an existing installation, but I cannot determine the
version number.  You must use the -f flag to force the upgrade."""))
            sys.exit(1)
        lastversion = 0x2000000  # 2.0.0

    # If the versions match, we don't need to do anything
    if lastversion == thisversion and not args.force:
        print(C_('No upgrade is necessary.'))
        # Early check: try to load all lists and print a summary
        list_names = Utils.list_names()
        ok = 0
        fail = 0
        for listname in list_names:
            try:
                if isinstance(listname, bytes):
                    listname = listname.decode('utf-8', 'replace')
                listname = listname.lower()
                mlist = MailList.MailList(listname, lock=0)
                ok += 1
            except Exception as e:
                fail += 1
                print('  [WARN] Could not load list "%s": %s' % (listname, str(e)))
        if fail == 0:
            print('All %d lists loaded successfully, no upgrade necessary.' % ok)
        else:
            print('%d lists loaded successfully, %d lists had errors. No upgrade necessary.' % (ok, fail))
        sys.exit(0)

    # If this is a downgrade, we need to force it
    if lastversion > thisversion and not args.force:
        print(C_("""\
This appears to be a downgrade.  You must use the -f flag to force the
downgrade."""))
        sys.exit(1)

    # Process all mailing lists
    list_names = Utils.list_names()
    print("Found %d lists to process" % len(list_names))
    print("List names type: %s" % type(list_names))
    
    for listname in list_names:
        mlist = None
        try:
            print("\nProcessing list: %s (type: %s)" % (listname, type(listname)))
            # Ensure listname is a string, not bytes
            if isinstance(listname, bytes):
                print("Converting bytes listname to string")
                listname = listname.decode('utf-8', 'replace')
            listname = listname.lower()
            print("Listname after conversion: %s (type: %s)" % (listname, type(listname)))
            
            print("Creating MailList object...")
            # Create the MailList object without lock first
            mlist = MailList.MailList(listname, lock=0)
            print("MailList object created successfully")
            
            print("Attempting to acquire lock...")
            try:
                # First try to acquire the lock normally
                try:
                    mlist.Lock(0.5)
                except AlreadyLockedError:
                    # If we get AlreadyLockedError, try to force unlock if the lock is stale
                    print("Lock appears to be set, checking if it's stale...")
                    try:
                        # Try to force unlock if the lock is stale
                        mlist.__lock.force_unlock()
                        print("Stale lock removed, retrying lock acquisition...")
                        mlist.Lock(0.5)
                    except Exception as e:
                        print(C_('WARNING: Could not remove stale lock: %(error)s') % {
                            'error': str(e)
                        }, file=sys.stderr)
                        continue
                
                print("Lock acquired, starting upgrade...")
                
                # Do the upgrade
                upgrade(mlist)
                print("Upgrade completed, saving...")
                mlist.Save()
                print("Save completed")
                
            except TimeOutError:
                print(C_('WARNING: could not acquire lock for list: %(listname)s') % {
                    'listname': listname
                }, file=sys.stderr)
                continue
            finally:
                if mlist is not None:
                    try:
                        print("Unlocking list...")
                        mlist.Unlock()
                    except Exception as e:
                        print(C_('WARNING: Error unlocking list %(listname)s: %(error)s') % {
                            'listname': listname,
                            'error': str(e)
                        }, file=sys.stderr)
            
        except Exception as e:
            print("\nDetailed error information:")
            print("List name: %s" % listname)
            print("List name type: %s" % type(listname))
            print("Error type: %s" % type(e))
            print("Error message: %s" % str(e))
            import traceback
            print("Traceback:")
            traceback.print_exc()
            print(C_('Error processing list %(listname)s: %(error)s') % {
                'listname': listname,
                'error': str(e)
            }, file=sys.stderr)

    # Save the new version
    try:
        fp = open(LMVFILE, 'w')
        print('%x' % thisversion, file=fp)
        fp.close()
    except IOError as e:
        print(C_('Could not save version number: %(error)s') % {'error': str(e)}, file=sys.stderr)
        sys.exit(1)

    print(C_('Upgrade complete.'))


def usage(exitcode=0):
    """Print usage information and exit with the given exit code."""
    print(__doc__ % {'PROGRAM': PROGRAM})
    sys.exit(exitcode)


if __name__ == '__main__':
    main()

