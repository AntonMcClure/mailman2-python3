#! @PYTHON@
#
# Copyright (C) 1998-2018 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Check a list's config database file for integrity.

All of the following files are checked:

    config.pck
    config.pck.last
    config.db
    config.db.last
    config.safety

It's okay if any of these are missing.  config.pck and config.pck.last are
pickled versions of the config database file for 2.1a3 and beyond.  config.db
and config.db.last are used in all earlier versions, and these are Python
marshals.  config.safety is a pickle written by 2.1a3 and beyond when the
primary config.pck file could not be read.

Usage: %(PROGRAM)s [options] [listname [listname ...]]
"""

import sys
import os
import errno
import argparse
import marshal
import pickle
import re

import paths
from Mailman import mm_cfg
from Mailman import Utils
from Mailman.MailList import MailList
from Mailman.i18n import C_

PROGRAM = sys.argv[0]


def parse_args():
    parser = argparse.ArgumentParser(description='Check a list\'s config database file for integrity.')
    parser.add_argument('-a', '--all', action='store_true', default=True,
                       help='Check the databases for all lists (default)')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Verbose output. The state of every tested file is printed')
    parser.add_argument('listnames', nargs='*',
                       help='List names to check (optional if --all is specified)')
    return parser.parse_args()


def load_pickle(fp):
    """Load a pickle file with Python 2/3 compatibility."""
    try:
        return pickle.load(fp, fix_imports=True, encoding='latin1')
    except Exception as e:
        print('Error loading pickle file: %s' % e)
        return None


def testfile(dbfile, verbose=False):
    # Use our safe loader
    loadfunc = load_pickle
    if dbfile.endswith('.db') or dbfile.endswith('.db.last'):
        loadfunc = marshal.load
    elif dbfile.endswith('.pck') or dbfile.endswith('.pck.last'):
        loadfunc = load_pickle
    else:
        assert 0
    if verbose:
        print('Processing file: %s' % dbfile)
        print('  File type: %s' % ('marshal' if dbfile.endswith('.db') else 'pickle'))
        print('  File size: %d bytes' % os.path.getsize(dbfile))
    fp = open(dbfile, 'rb')
    try:
        data = loadfunc(fp)
        if verbose:
            print('  Successfully loaded data')
            if isinstance(data, dict):
                print('  Number of entries: %d' % len(data))
                if 'version' in data:
                    print('  Database version: %s' % data['version'])
        # Handle string/bytes conversion with better error handling
        if isinstance(data, bytes):
            try:
                data = data.decode('utf-8', 'replace')
            except Exception as e:
                if verbose:
                    print('  Warning: Error decoding bytes: %s' % str(e))
                data = str(data)
        elif isinstance(data, dict):
            new_data = {}
            for k, v in data.items():
                try:
                    if isinstance(k, bytes):
                        k = k.decode('utf-8', 'replace')
                    if isinstance(v, bytes):
                        v = v.decode('utf-8', 'replace')
                    elif isinstance(v, (list, tuple)):
                        v = list(v)
                        for i, item in enumerate(v):
                            if isinstance(item, bytes):
                                try:
                                    v[i] = item.decode('utf-8', 'replace')
                                except Exception as e:
                                    if verbose:
                                        print('  Warning: Error decoding list item: %s' % str(e))
                                    v[i] = str(item)
                    new_data[k] = v
                except Exception as e:
                    if verbose:
                        print('  Warning: Error processing dictionary item: %s' % str(e))
                    new_data[str(k)] = str(v)
            data = new_data
        elif isinstance(data, (list, tuple)):
            data = list(data)
            for i, item in enumerate(data):
                if isinstance(item, bytes):
                    try:
                        data[i] = item.decode('utf-8', 'replace')
                    except Exception as e:
                        if verbose:
                            print('  Warning: Error decoding list item: %s' % str(e))
                        data[i] = str(item)
        return data
    except Exception as e:
        if verbose:
            print('  Error loading file: %s' % str(e))
        raise
    finally:
        fp.close()


def main():
    args = parse_args()
    try:
        if args.all or not args.listnames:
            listnames = Utils.list_names()
            if args.verbose:
                print('Checking all lists (%d total)' % len(listnames))
        else:
            listnames = args.listnames
            if args.verbose:
                print('Checking specified lists (%d total)' % len(listnames))

        # Convert list names to lowercase and strip whitespace
        listnames = [n.lower().strip() for n in listnames]
        if not listnames:
            print('No lists found to check.')
            sys.exit(0)

        for listname in listnames:
            if args.verbose:
                print('\nProcessing list: %s' % listname)
            
            # Validate list name format
            if len(re.sub(mm_cfg.ACCEPTABLE_LISTNAME_CHARACTERS, '', listname)) > 0:
                print('  Invalid list name format: %s' % listname)
                continue

            listdir = os.path.join(mm_cfg.LIST_DATA_DIR, listname)
            if not os.path.exists(listdir):
                if args.verbose:
                    print('  List directory does not exist: %s' % listdir)
                continue

            # Check if any of the required files exist
            required_files = [
                os.path.join(listdir, 'config.pck'),
                os.path.join(listdir, 'config.pck.last'),
                os.path.join(listdir, 'config.db'),
                os.path.join(listdir, 'config.db.last'),
                os.path.join(listdir, 'config.safety'),
            ]
            
            has_required_files = any(os.path.exists(f) for f in required_files)
            if not has_required_files:
                if args.verbose:
                    print('  No configuration files found for list: %s' % listname)
                continue

            # Check all possible database files
            dbfiles = required_files + [
                os.path.join(listdir, 'request.pck'),
                os.path.join(listdir, 'request.pck.bak'),
            ]

            for dbfile in dbfiles:
                if os.path.exists(dbfile):
                    try:
                        testfile(dbfile, args.verbose)
                        if args.verbose:
                            print('  File %s: OK' % os.path.basename(dbfile))
                    except Exception as e:
                        print('  File %s: ERROR - %s' % (os.path.basename(dbfile), str(e)))
                elif args.verbose:
                    print('  File %s: Not found' % os.path.basename(dbfile))
    except Exception as e:
        print('Error getting list names: %s' % str(e))
        sys.exit(1)


if __name__ == '__main__':
    main()
