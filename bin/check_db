#! @PYTHON@
#
# Copyright (C) 1998-2018 by the Free Software Foundation, Inc.
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software 
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.

"""Check a list's config database file for integrity.

All of the following files are checked:

    config.pck
    config.pck.last
    config.db
    config.db.last
    config.safety

It's okay if any of these are missing.  config.pck and config.pck.last are
pickled versions of the config database file for 2.1a3 and beyond.  config.db
and config.db.last are used in all earlier versions, and these are Python
marshals.  config.safety is a pickle written by 2.1a3 and beyond when the
primary config.pck file could not be read.

Usage: %(PROGRAM)s [options] [listname [listname ...]]
"""

import sys
import os
import errno
import argparse
import marshal
import pickle

import paths
from Mailman import mm_cfg
from Mailman import Utils
from Mailman.MailList import MailList
from Mailman.i18n import C_

PROGRAM = sys.argv[0]


def parse_args():
    parser = argparse.ArgumentParser(description='Check a list\'s config database file for integrity.')
    parser.add_argument('-a', '--all', action='store_true',
                       help='Check the databases for all lists')
    parser.add_argument('-v', '--verbose', action='store_true',
                       help='Verbose output. The state of every tested file is printed')
    parser.add_argument('listnames', nargs='*',
                       help='List names to check (optional if --all is specified)')
    return parser.parse_args()


def testfile(dbfile):
    if dbfile.endswith('.db') or dbfile.endswith('.db.last'):
        loadfunc = marshal.load
    elif dbfile.endswith('.pck') or dbfile.endswith('.pck.last'):
        loadfunc = pickle.load
    else:
        assert 0
    fp = open(dbfile, 'rb')
    try:
        data = loadfunc(fp)
        # Handle string/bytes conversion
        if isinstance(data, bytes):
            data = data.decode('utf-8', 'replace')
        elif isinstance(data, dict):
            new_data = {}
            for k, v in data.items():
                if isinstance(k, bytes):
                    k = k.decode('utf-8', 'replace')
                if isinstance(v, bytes):
                    v = v.decode('utf-8', 'replace')
                elif isinstance(v, (list, tuple)):
                    v = list(v)  # Convert tuple to list for modification
                    for i, item in enumerate(v):
                        if isinstance(item, bytes):
                            v[i] = item.decode('utf-8', 'replace')
                new_data[k] = v
            data = new_data
        elif isinstance(data, (list, tuple)):
            data = list(data)  # Convert tuple to list for modification
            for i, item in enumerate(data):
                if isinstance(item, bytes):
                    data[i] = item.decode('utf-8', 'replace')
    finally:
        fp.close()


def main():
    args = parse_args()

    listnames = args.listnames
    if args.all:
        listnames = Utils.list_names()

    listnames = [n.lower().strip() for n in listnames]
    if not listnames:
        print(C_('Nothing to do.'))
        sys.exit(0)

    for listname in listnames:
        if not Utils.list_exists(listname):
            print(C_('No list named:'), listname)
            continue
        mlist = MailList(listname, lock=0)
        pfile = os.path.join(mlist.fullpath(), 'config.pck')
        plast = pfile + '.last'
        dfile = os.path.join(mlist.fullpath(), 'config.db')
        dlast = dfile + '.last'

        if args.verbose:
            print(C_('List:'), listname)

        for file in (pfile, plast, dfile, dlast):
            status = 0
            try:
                testfile(file)
            except IOError as e:
                # Don't report ENOENT unless we're in verbose mode
                if args.verbose or e.errno != errno.ENOENT:
                    status = e
            except Exception as e:
                status = e
            # Report errors
            if status:
                if isinstance(status, EnvironmentError):
                    # This already includes the file name
                    print('   ', status)
                else:
                    print('    %s: %s' % (file, status))
            elif args.verbose:
                print(C_('   %(file)s: okay'))


if __name__ == '__main__':
    main()
